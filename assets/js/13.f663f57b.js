(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{416:function(t,n,a){"use strict";a.r(n);var e=a(2),o=Object(e.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("blockquote",[n("p",[t._v("学习了一篇 js 偏底层基础 的文章：JavaScript 的执行上下文 Execution context")]),t._v(" "),n("p",[t._v("我将三篇文章放在一起 最后加了一些自己的总结 和 函数表达式的理解")]),t._v(" "),n("p",[t._v("原文地址：")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.cnblogs.com/wilber2013/p/4909430.html#_nav_0",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 的执行上下文"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.cnblogs.com/wilber2013/p/4909459.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("理解 JavaScript 的作用域链"),n("OutboundLink")],1)]),t._v(" "),n("p",[n("a",{attrs:{href:"https://www.cnblogs.com/wilber2013/p/4909505.html#_nav_3",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 中的 this"),n("OutboundLink")],1)])]),t._v(" "),n("h1",{attrs:{id:"javascript-的执行上下文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-的执行上下文"}},[t._v("#")]),t._v(" JavaScript 的执行上下文")]),t._v(" "),n("p",[t._v('在 JavaScript 的运行过程中，经常会遇到一些"奇怪"的行为，不理解为什么 JavaScript 会这么工作。')]),t._v(" "),n("p",[t._v("这时候可能就需要了解一下 JavaScript 执行过程中的相关内容了。")]),t._v(" "),n("h2",{attrs:{id:"执行上下文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),n("p",[t._v("在 JavaScript 中有三种代码运行环境：")]),t._v(" "),n("ul",[n("li",[t._v("Global Code\n"),n("ul",[n("li",[t._v("JavaScript 代码开始运行的默认环境")])])]),t._v(" "),n("li",[t._v("Function Code\n"),n("ul",[n("li",[t._v("代码进入一个 JavaScript 函数")])])]),t._v(" "),n("li",[t._v("Eval Code\n"),n("ul",[n("li",[t._v("使用 eval()执行代码")])])])]),t._v(" "),n("p",[t._v("为了表示不同的运行环境，JavaScript 中有一个"),n("strong",[t._v("执行上下文（Execution context，EC）"),n("strong",[t._v("的概念。也就是说，当 JavaScript 代码执行的时候，会进入不同的执行上下文，这些执行上下文就构成了一个")]),t._v("执行上下文栈（Execution context stack，ECS）")]),t._v("。")]),t._v(" "),n("p",[t._v("例如对如下面的 JavaScript 代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var a = "global var";\n\nfunction foo(){\n    console.log(a);\n}\n\nfunction outerFunc(){\n    var b = "var in outerFunc";\n    console.log(b);\n\n    function innerFunc(){\n        var c = "var in innerFunc";\n        console.log(c);\n        foo();\n    }\n\n    innerFunc();\n}\n\n\nouterFunc()\n')])])]),n("p",[t._v("代码首先进入 Global Execution Context，然后依次进入 outerFunc，innerFunc 和 foo 的执行上下文，执行上下文栈就可以表示为：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/x8ESa2bl3QDycL1.png",alt:"img"}})]),t._v(" "),n("p",[t._v("当 JavaScript 代码执行的时候，第一个进入的总是默认的 Global Execution Context，所以说它总是在 ECS 的最底部。")]),t._v(" "),n("p",[t._v("对于每个 Execution Context 都有三个重要的属性，变量对象（Variable object，VO），作用域链（Scope chain）和 this。这三个属性跟代码运行的行为有很重要的关系，下面会一一介绍。")]),t._v(" "),n("p",[t._v("当然，除了这三个属性之外，根据实现的需要，Execution Context 还可以有一些附加属性。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/pYxDIs58lHcJzO7.png",alt:"img"}})]),t._v(" "),n("h2",{attrs:{id:"vo-和-ao"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vo-和-ao"}},[t._v("#")]),t._v(" VO 和 AO")]),t._v(" "),n("p",[t._v("从上面看到，在 Execution Context 中，会保存变量对象（Variable object，VO），下面就看看变量对象是什么。")]),t._v(" "),n("h3",{attrs:{id:"变量对象-variable-object"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#变量对象-variable-object"}},[t._v("#")]),t._v(" 变量对象（Variable object）")]),t._v(" "),n("p",[t._v("变量对象是与执行上下文相关的数据作用域。它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明。也就是说，一般 VO 中会包含以下信息：")]),t._v(" "),n("ul",[n("li",[t._v("变量 (var, Variable Declaration);")]),t._v(" "),n("li",[t._v("函数声明 (Function Declaration, FD);")]),t._v(" "),n("li",[t._v("函数的形参")])]),t._v(" "),n("p",[t._v("当 JavaScript 代码运行中，如果试图寻找一个变量的时候，就会首先查找 VO。对于前面例子中的代码，Global Execution Context 中的 VO 就可以表示如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/Aq9PveDLEjmzxMN.png",alt:"img"}})]),t._v(" "),n("p",[t._v("**注意，**假如上面的例子代码中有下面两个语句，Global VO 仍将不变。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('(function bar(){}) // function expression, FE\nbaz = "property of global object"\n')])])]),n("p",[t._v("也就是说，对于 VO，是有下面两种特殊情况的：")]),t._v(" "),n("ul",[n("li",[t._v("函数表达式（与函数声明相对）不包含在 VO 之中")]),t._v(" "),n("li",[t._v('没有使用 var 声明的变量（这种变量是，"全局"的声明方式，只是给 Global 添加了一个属性，并不在 VO 中）')])]),t._v(" "),n("h3",{attrs:{id:"活动对象-activation-object"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#活动对象-activation-object"}},[t._v("#")]),t._v(" 活动对象（Activation object）")]),t._v(" "),n("p",[t._v("只有全局上下文的变量对象允许通过 VO 的属性名称间接访问；在函数执行上下文中，VO 是不能直接访问的，此时由激活对象(Activation Object,缩写为 AO)扮演 VO 的角色。激活对象 是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。")]),t._v(" "),n("p",[t._v("Arguments Objects 是函数上下文里的激活对象 AO 中的内部对象，它包括下列属性：")]),t._v(" "),n("ol",[n("li",[t._v("callee：指向当前函数的引用")]),t._v(" "),n("li",[t._v("length： 真正传递的参数的个数")]),t._v(" "),n("li",[t._v("properties-indexes：就是函数的参数值(按参数列表从左到右排列)")])]),t._v(" "),n("p",[t._v("对于 VO 和 AO 的关系可以理解为，VO 在不同的 Execution Context 中会有不同的表现：当在 Global Execution Context 中，可以直接使用 VO；但是，在函数 Execution Context 中，AO 就会被创建。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://images2015.cnblogs.com/blog/593627/201510/593627-20151025201155177-724394618.png",alt:"img"}})]),t._v(" "),n("p",[t._v("当上面的例子开始执行 outerFunc 的时候，就会有一个 outerFunc 的 AO 被创建：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/3iIzJmXVdKgDeq4.png",alt:"img"}})]),t._v(" "),n("p",[t._v("通过上面的介绍，我们现在了解了 VO 和 AO 是什么，以及他们之间的关系了。下面就需要看看 JavaScript 解释器是怎么执行一段代码，以及设置 VO 和 AO 了。")]),t._v(" "),n("h2",{attrs:{id:"细看-execution-context"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#细看-execution-context"}},[t._v("#")]),t._v(" 细看 Execution Context")]),t._v(" "),n("p",[t._v("当一段 JavaScript 代码执行的时候，JavaScript 解释器会创建 Execution Context，其实这里会有两个阶段：")]),t._v(" "),n("ul",[n("li",[t._v("创建阶段（当函数被调用，但是开始执行函数内部代码之前）\n"),n("ul",[n("li",[t._v("创建 Scope chain")]),t._v(" "),n("li",[t._v("创建 VO/AO（variables, functions and arguments）")]),t._v(" "),n("li",[t._v("设置 this 的值")])])]),t._v(" "),n("li",[t._v("激活/代码执行阶段\n"),n("ul",[n("li",[t._v("设置变量的值、函数的引用，然后解释/执行代码")])])])]),t._v(" "),n("p",[t._v('这里想要详细介绍一下"创建 VO/AO"中的一些细节，因为这些内容将直接影响代码运行的行为。')]),t._v(" "),n("p",[t._v('对于"创建 VO/AO"这一步，JavaScript 解释器主要做了下面的事情：')]),t._v(" "),n("ul",[n("li",[t._v("根据函数的参数，创建并初始化 arguments object")]),t._v(" "),n("li",[t._v("扫描函数内部代码，查找函数声明（Function declaration）\n"),n("ul",[n("li",[t._v("对于所有找到的函数声明，将函数名和函数引用存入 VO/AO 中")]),t._v(" "),n("li",[n("strong",[t._v("如果 VO/AO 中已经有同名的函数，那么就进行覆盖")])])])]),t._v(" "),n("li",[t._v("扫描函数内部代码，查找变量声明（Variable declaration）\n"),n("ul",[n("li",[t._v('对于所有找到的变量声明，将变量名存入 VO/AO 中，并初始化为"undefined"')]),t._v(" "),n("li",[t._v("如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性")])])])]),t._v(" "),n("p",[t._v("看下面的例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function foo(i) {\n    var a = 'hello';\n    var b = function privateB() {\n\n    };\n    function c() {\n\n    }\n}\n\nfoo(22);\n")])])]),n("p",[t._v('对于上面的代码，在"创建阶段"，可以得到下面的 Execution Context object：')]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("fooExecutionContext = {\n    scopeChain: { ... },\n    variableObject: {\n        arguments: {\n            0: 22,\n            length: 1\n        },\n        i: 22,\n        c: pointer to function c()\n        a: undefined,\n        b: undefined\n    },\n    this: { ... }\n}\n")])])]),n("p",[t._v('在"激活/代码执行阶段"，Execution Context object 就被更新为：')]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("fooExecutionContext = {\n    scopeChain: { ... },\n    variableObject: {\n        arguments: {\n            0: 22,\n            length: 1\n        },\n        i: 22,\n        c: pointer to function c()\n        a: 'hello',\n        b: pointer to function privateB()\n    },\n    this: { ... }\n}\n")])])]),n("h2",{attrs:{id:"例子分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#例子分析"}},[t._v("#")]),t._v(" 例子分析")]),t._v(" "),n("p",[t._v("前面介绍了 Execution Context，VO/AO 等这么多的理论知识，当然是为了方便我们去分析代码中的一些行为。这里，就通过几个简单的例子，结合上面的概念来分析结果。")]),t._v(" "),n("h3",{attrs:{id:"example-1"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-1"}},[t._v("#")]),t._v(" Example 1")]),t._v(" "),n("p",[t._v("首先看第一个例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('(function(){\n    console.log(bar);\n    console.log(baz);\n\n    var bar = 20;\n\n    function baz(){\n        console.log("baz");\n    }\n\n})()\n')])])]),n("p",[t._v("在 Chrome 中运行代码运行后将输出：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://images2015.cnblogs.com/blog/593627/201510/593627-20151025201157161-1227329780.png",alt:"img"}})]),t._v(" "),n("p",[t._v('代码解释：匿名函数会首先进入"创建结果"，JavaScript 解释器会创建一个"Function Execution Context"，然后创建 Scope chain，VO/AO 和 this。根据前面的介绍，解释器会扫描函数和变量声明，如下的 AO 会被创建：')]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/WJOV6it78FUuBvw.png",alt:"img"}})]),t._v(" "),n("p",[t._v('所以，对于 bar，我们会得到"undefined"这个输出，表现的行为就是，我们在声明一个变量之前就访问了这个变量。这个就是 JavaScript 中"Hoisting"。')]),t._v(" "),n("h3",{attrs:{id:"example-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-2"}},[t._v("#")]),t._v(" Example 2")]),t._v(" "),n("p",[t._v("接着上面的例子，进行一些修改：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('(function(){\n    console.log(bar);\n    console.log(baz);\n\n    bar = 20;\n    console.log(window.bar);\n    console.log(bar);\n\n    function baz(){\n        console.log("baz");\n    }\n\n})()\n')])])]),n("p",[t._v('运行这段代码会得到"bar is not defined(…)"错误。当代码执行到"console.log(bar);"的时候，会去 AO 中查找"bar"。但是，根据前面的解释，函数中的"bar"并没有通过 var 关键字声明，所有不会被存放在 AO 中，也就有了这个错误。')]),t._v(" "),n("p",[t._v('注释掉"console.log(bar);"，再次运行代码，可以得到下面结果。"bar"在"激活/代码执行阶段"被创建。')]),t._v(" "),n("p",[n("img",{attrs:{src:"https://images2015.cnblogs.com/blog/593627/201510/593627-20151025201158911-154792588.png",alt:"img"}})]),t._v(" "),n("h3",{attrs:{id:"example-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-3"}},[t._v("#")]),t._v(" Example 3")]),t._v(" "),n("p",[t._v("现在来看最后一个例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('(function(){\n    console.log(foo);\n    console.log(bar);\n    console.log(baz);\n\n    var foo = function(){};\n\n    function bar(){\n        console.log("bar");\n    }\n\n    var bar = 20;\n    console.log(bar);\n\n    function baz(){\n        console.log("baz");\n    }\n\n})()\n')])])]),n("p",[t._v("代码的运行结果为：")]),t._v(" "),n("p",[t._v('代码中，最"奇怪"的地方应该就是"bar"的输出了，第一次是一个函数，第二次是"20"。')]),t._v(" "),n("p",[t._v('其实也很好解释，回到前面对"创建 VO/AO"的介绍，在创建 VO/AO 过程中，解释器会先扫描函数声明，然后"foo: '),n("code",[t._v("<function>")]),t._v('"就被保存在了 AO 中；但解释器扫描变量声明的时候，虽然发现"var bar = 20;"，但是因为"foo"在 AO 中已经存在，所以就没有任何操作了。')]),t._v(" "),n("p",[t._v('但是，当代码执行到第二句"console.log(bar);"的时候，"激活/代码执行阶段"已经把 AO 中的"bar"重新设置了。')]),t._v(" "),n("blockquote",[n("p",[t._v("下面是自己理解的 函数内部上下文执行流程图")])]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/EJQujlLwZq8R321.png",alt:"JavaScript的执行上下文（函数内部的执行流程Execution Context）"}})]),t._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("本文介绍了 JavaScript 中的执行上下文（Execution Context），以及 VO/AO 等概念，最后通过几个例子展示了这几个概念对我们了解 JavaScript 代码运行的重要性。")]),t._v(" "),n("p",[t._v('通过对 VO/AO 在"创建阶段"的具体细节，如何扫描函数声明和变量声明，就可以对 JavaScript 中的"Hoisting"有清晰的认识。所以说，了解 JavaScript 解释器的行为，以及相关的概念，对理解 JavaScript 代码的行为是很有帮助的。')]),t._v(" "),n("p",[t._v("后面会对 Execution Context 中的 Scope chain 和 this 进行介绍。")]),t._v(" "),n("h1",{attrs:{id:"理解-javascript-的作用域链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#理解-javascript-的作用域链"}},[t._v("#")]),t._v(" 理解 JavaScript 的作用域链")]),t._v(" "),n("p",[t._v("上一篇文章中介绍了 Execution Context 中的三个重要部分：VO/AO，scope chain 和 this，并详细的介绍了 VO/AO 在 JavaScript 代码执行中的表现。")]),t._v(" "),n("p",[t._v("本文就看看 Execution Context 中的 scope chain。")]),t._v(" "),n("h2",{attrs:{id:"作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),n("p",[t._v("开始介绍作用域链之前，先看看 JavaScript 中的作用域（scope）。在很多语言中（C++，C#，Java），作用域都是通过代码块（由{}包起来的代码）来决定的，"),n("strong",[t._v("但是，在 JavaScript 作用域是跟函数相关的，也可以说成是 function-based。")])]),t._v(" "),n("p",[t._v('例如，当 for 循环这个代码块结束后，依然可以访问变量"i"。')]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("for(var i = 0; i < 3; i++){\n    console.log(i);\n}\n\nconsole.log(i); //3\n")])])]),n("p",[t._v("对于作用域，又可以分为全局作用域（Global scope）和局部作用域（Local scpoe）。")]),t._v(" "),n("p",[n("strong",[t._v("全局作用域")]),t._v("中的对象可以在代码的任何地方访问，一般来说，下面情况的对象会在全局作用域中：")]),t._v(" "),n("ul",[n("li",[t._v("最外层函数和在最外层函数外面定义的变量")]),t._v(" "),n("li",[t._v('没有通过关键字"var"声明的变量')]),t._v(" "),n("li",[t._v("浏览器中，window 对象的属性")])]),t._v(" "),n("p",[n("strong",[t._v("局部作用域")]),t._v("又被称为函数作用域（Function scope），所有的变量和函数只能在作用域内部使用。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var foo = 1;\nwindow.bar = 2;\n\nfunction baz(){\n    a = 3;\n    var b = 4;\n}\n// Global scope: foo, bar, baz, a\n// Local scope: b\n")])])]),n("h2",{attrs:{id:"作用域链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),n("p",[t._v("通过前面一篇文章了解到，每一个 Execution Context 中都有一个 VO，用来存放变量，函数和参数等信息。")]),t._v(" "),n("p",[t._v("在 JavaScript 代码运行中，所有用到的变量都需要去当前 AO/VO 中查找，当找不到的时候，就会继续查找上层 Execution Context 中的 AO/VO。这样一级级向上查找的过程，就是所有 Execution Context 中的 AO/VO 组成了一个作用域链。")]),t._v(" "),n("p",[t._v("所以说，"),n("strong",[t._v("作用域链")]),t._v("与一个执行上下文相关，是内部上下文所有变量对象（包括父变量对象）的列表，用于变量查询。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Scope = VO/AO + All Parent VO/AOs\n")])])]),n("p",[t._v("看一个例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var x = 10;\n\nfunction foo() {\n    var y = 20;\n\n    function bar() {\n        var z = 30;\n\n        console.log(x + y + z);\n    };\n\n    bar()\n};\n\nfoo();\n")])])]),n("p",[t._v('上面代码的输出结果为"60"，函数 bar 可以直接访问"z"，然后通过作用域链访问上层的"x"和"y"。')]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/4GWK2pgfCJLjS7U.png",alt:"img"}})]),t._v(" "),n("ul",[n("li",[t._v("绿色箭头指向 VO/AO")]),t._v(" "),n("li",[t._v("蓝色箭头指向 scope chain（VO/AO + All Parent VO/AOs）")])]),t._v(" "),n("p",[t._v("再看一个比较典型的例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var data = [];\nfor(var i = 0 ; i < 3; i++){\n    data[i]=function() {\n        console.log(i);\n    }\n}\n\ndata[0]();// 3\ndata[1]();// 3\ndata[2]();// 3\n")])])]),n("p",[t._v('第一感觉（错觉）这段代码会输出"0，1，2"。但是根据前面的介绍，变量"i"是存放在"Global VO"中的变量，循环结束后"i"的值就被设置为 3，所以代码最后的三次函数调用访问的是相同的"Global VO"中已经被更新的"i"。')]),t._v(" "),n("h2",{attrs:{id:"结合作用域链看闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#结合作用域链看闭包"}},[t._v("#")]),t._v(" 结合作用域链看闭包")]),t._v(" "),n("p",[t._v("在 JavaScript 中，闭包跟作用域链有紧密的关系。相信大家对下面的闭包例子一定非常熟悉，代码中通过闭包实现了一个简单的计数器。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function counter() {\n    var x = 0;\n\n    return {\n        increase: function increase() { return ++x; },\n        decrease: function decrease() { return --x; }\n    };\n}\n\nvar ctor = counter();\n\nconsole.log(ctor.increase());\nconsole.log(ctor.decrease());\n")])])]),n("p",[t._v("下面我们就通过 Execution Context 和 scope chain 来看看在上面闭包代码执行中到底做了哪些事情。")]),t._v(" "),n("p",[t._v("\\1. 当代码进入 Global Context 后，会创建 Global VO")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/kG1t9AVEXPhivCg.png",alt:"img"}})]),t._v(" "),n("ul",[n("li",[t._v("绿色箭头指向 VO/AO")]),t._v(" "),n("li",[t._v("蓝色箭头指向 scope chain（VO/AO + All Parent VO/AOs）")])]),t._v(" "),n("p",[t._v('\\2. 当代码执行到"var cter = counter();"语句的时候，进入 counter Execution Context；根据上一篇文章的介绍，这里会创建 counter AO，并设置 counter Execution Context 的 scope chain')]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/ZrsJ4g6pHXG3uBF.png",alt:"img"}})]),t._v(" "),n("p",[t._v("\\3. 当 counter 函数执行的最后，并退出的时候，Global VO 中的 ctor 就会被设置；这里需要注意的是，虽然 counter Execution Context 退出了执行上下文栈，但是因为 ctor 中的成员仍然引用 counter AO（因为 counter AO 是 increase 和 decrease 函数的 parent scope），所以 counter AO 依然在 Scope 中。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/mFMpR6gDWoE5a3c.png",alt:"img"}})]),t._v(" "),n("p",[t._v('\\4. 当执行"ctor.increase()"代码的时候，代码将进入 ctor.increase Execution Context，并为该执行上下文创建 VO/AO，scope chain 和设置 this；这时，ctor.increase AO 将指向 counter AO。')]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/53RuG7NtsSfjLZ4.png",alt:"img"}})]),t._v(" "),n("ul",[n("li",[t._v("绿色箭头指向 VO/AO")]),t._v(" "),n("li",[t._v("蓝色箭头指向 scope chain（VO/AO + All Parent VO/AOs）")]),t._v(" "),n("li",[t._v("红色箭头指向 this")]),t._v(" "),n("li",[t._v("黑色箭头指向 parent VO/AO")])]),t._v(" "),n("p",[t._v("相信看到这些，一定会对 JavaScript 闭包有了比较清晰的认识，也了解为什么 counter Execution Context 退出了执行上下文栈，但是 counter AO 没有销毁，可以继续访问。")]),t._v(" "),n("h2",{attrs:{id:"二维作用域链查找"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二维作用域链查找"}},[t._v("#")]),t._v(" 二维作用域链查找")]),t._v(" "),n("p",[t._v("通过上面了解到，作用域链（scope chain）的主要作用就是用来进行变量查找。但是，在 JavaScript 中还有原型链（prototype chain）的概念。")]),t._v(" "),n("p",[t._v("由于作用域链和原型链的相互作用，这样就形成了一个二维的查找。")]),t._v(" "),n("p",[t._v("对于这个二维查找可以总结为："),n("strong",[t._v("当代码需要查找一个属性（property）或者描述符（identifier）的时候，首先会通过作用域链（scope chain）来查找相关的对象；一旦对象被找到，就会根据对象的原型链（prototype chain）来查找属性（property）")]),t._v("。")]),t._v(" "),n("p",[t._v("下面通过一个例子来看看这个二维查找：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var foo = {}\n\nfunction baz() {\n\n    Object.prototype.a = 'Set foo.a from prototype';\n\n    return function inner() {\n        console.log(foo.a);\n    }\n\n}\n\nbaz()();\n// Set bar.a from prototype\n")])])]),n("p",[t._v('对于这个例子，可以通过下图进行解释，代码首先通过作用域链（scope chain）查找"foo"，最终在 Global context 中找到；然后因为"foo"中没有找到属性"a"，将继续沿着原型链（prototype chain）查找属性"a"。')]),t._v(" "),n("p",[n("img",{attrs:{src:"https://s2.loli.net/2023/01/13/VfyoDZcaGinH4dC.png",alt:"img"}})]),t._v(" "),n("ul",[n("li",[t._v("蓝色箭头表示作用域链查找")]),t._v(" "),n("li",[t._v("橘色箭头表示原型链查找")])]),t._v(" "),n("h2",{attrs:{id:"总结-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("本文介绍了 JavaScript 中的作用域以及作用域链，通过作用域链分析了闭包的执行过程，进一步认识了 JavaScript 的闭包。")]),t._v(" "),n("p",[t._v("同时，结合原型链，演示了 JavaScript 中的描述符和属性的查找。")]),t._v(" "),n("p",[t._v("下一篇我们就看看 Execution Context 中的 this 属性。")]),t._v(" "),n("h1",{attrs:{id:"javascript-中的-this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中的-this"}},[t._v("#")]),t._v(" JavaScript 中的 this")]),t._v(" "),n("p",[t._v("前面两篇文章介绍了 JavaScript 执行上下文中两个重要属性：VO/AO 和 scope chain。本文就来看看执行上下文中的 this。")]),t._v(" "),n("p",[t._v("首先看看下面两个对 this 的概括：")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("this 是执行上下文（Execution Context）的一个重要属性")]),t._v("，是一个与执行上下文相关的特殊对象。因此，它可以叫作上下文对象（也就是用来指明执行上下文是在哪个上下文中被触发的对象）。")]),t._v(" "),n("li",[n("strong",[t._v("this 不是变量对象（Variable Object）的一个属性")]),t._v("，所以跟变量不同，this 从不会参与到标识符解析过程。也就是说，在代码中当访问 this 的时候，它的值是直接从执行上下文中获取的，并不需要任何作用域链查找。this 的值只在进入上下文的时候进行一次确定。")])]),t._v(" "),n("p",[t._v("关于 this 最困惑的应该是，同一个函数，当在不同的上下文进行调用的时候，this 的值就可能会不同。也就是说，this 的值是通过函数调用表达式（也就是函数被调用的方式）的 caller 所提供的。")]),t._v(" "),n("p",[t._v("下面就看看在不同场景中，this 的值。")]),t._v(" "),n("h2",{attrs:{id:"全局上下文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全局上下文"}},[t._v("#")]),t._v(" 全局上下文")]),t._v(" "),n("p",[t._v("在全局上下文（Global Context）中，this 总是 global object，在浏览器中就是 window 对象。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('console.log(this === window);\n\nthis.name = "Will";\nthis.age = 28;\nthis.getInfo = function(){\n    console.log(this.name + " is " + this.age + " years old");\n};\nwindow.getInfo();\n// true\n// Will is 28 years old\n')])])]),n("h2",{attrs:{id:"函数上下文"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数上下文"}},[t._v("#")]),t._v(" 函数上下文")]),t._v(" "),n("p",[t._v("在一个函数中，this 的情况就比较多了，this 的值直接受函数调用方式的影响。")]),t._v(" "),n("h3",{attrs:{id:"invoke-function-as-function"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#invoke-function-as-function"}},[t._v("#")]),t._v(" Invoke function as Function")]),t._v(" "),n("p",[t._v("当通过正常的方式调用一个函数的时候，this 的值就会被设置为 global object（浏览器中的 window 对象）。")]),t._v(" "),n("p",[t._v('但是，当使用"strict mode"执行下面代码的时候，this 就会被设置为"undefined"。')]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function gFunc(){\n    return this;\n}\n\nconsole.log(gFunc());\nconsole.log(this === window.gFunc());\n// window\n// true\n")])])]),n("h3",{attrs:{id:"invoke-function-as-method"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#invoke-function-as-method"}},[t._v("#")]),t._v(" Invoke function as Method")]),t._v(" "),n("p",[t._v("当函数作为一个对象方法来执行的时候，this 的值就是该方法所属的对象。")]),t._v(" "),n("p",[t._v('在下面的例子中，创建了一个 obj 对象，并设置 name 属性的值为"obj"。所以但调用该对象的 func 方法的时候，方法中的 this 就表示 obj 这个对象。')]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var obj = {\n    name: "obj",\n    func: function () {\n        console.log(this + ":" + this.name);\n    }\n};\n\nobj.func();\n// [object Object]:obj\n')])])]),n("p",[t._v('为了验证"方法中的 this 代表方法所属的对象"这句话，再看下面一个例子。')]),t._v(" "),n("p",[t._v("在对象 obj 中，创建了一个内嵌对象 nestedObj，当调用内嵌对象的方法的时候，方法中的 this 就代表 nestedObj。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var obj = {\n    name: "obj",\n    nestedObj: {\n        name:"nestedObj",\n        func: function () {\n            console.log(this + ":" + this.name);\n        }\n    }\n}\n\nobj.nestedObj.func();\n// [object Object]:nestedObj\n')])])]),n("p",[t._v("对于上面例子中的方法，通常称为绑定方法，也就是说这些方法都是个特定的对象关联的。")]),t._v(" "),n("p",[t._v("但是，当我们进行下面操作的时候，temp 将是一个全局作用里面的函数，并没有绑定到 obj 对象上。所以，temp 中的 this 表示的是 window 对象。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var name = "Will";\nvar obj = {\n    name: "obj",\n    func: function () {\n        console.log(this + ":" + this.name);\n    }\n};\n\ntemp = obj.func;\ntemp();\n//  [object Window]:Will\n')])])]),n("h3",{attrs:{id:"invoke-function-as-constructor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#invoke-function-as-constructor"}},[t._v("#")]),t._v(" Invoke function as Constructor")]),t._v(" "),n("p",[t._v("在 JavaScript 中，函数可以作为构造器来直接创建对象，在这种情况下，this 就代表了新建的对象。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function Staff(name, age){\n    this.name = name;\n    this.age = age;\n    this.getInfo = function(){\n        console.log(this.name + " is " + this.age + " years old");\n    };\n}\n\nvar will = new Staff("Will", 28);\nwill.getInfo();\n// Will is 28 years old\n')])])]),n("h3",{attrs:{id:"invoke-context-less-function"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#invoke-context-less-function"}},[t._v("#")]),t._v(" Invoke context-less function")]),t._v(" "),n("p",[t._v("对于有些没有上下文的函数，也就是说这些函数没有绑定到特定的对象上，那么这些上下文无关的函数将会被默认的绑定到 global object 上。")]),t._v(" "),n("p",[t._v("在这个例子中，函数 f 和匿名函数表达式在被调用的过程中并没有被关联到任何对象，所以他们的 this 都代表 global object。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var context = "global";\n\nvar obj = {\n    context: "object",\n    method: function () {\n        console.log(this + ":" +this.context);\n\n        function f() {\n            var context = "function";\n            console.log(this + ":" +this.context);\n        };\n        f();\n\n        (function(){\n            var context = "function";\n            console.log(this + ":" +this.context);\n        })();\n    }\n};\n\nobj.method();\n// [object Object]:object\n// [object Window]:global\n// [object Window]:global\n')])])]),n("h2",{attrs:{id:"call-apply-bind-改变-this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind-改变-this"}},[t._v("#")]),t._v(" call/apply/bind 改变 this")]),t._v(" "),n("p",[t._v("this 本身是不可变的，但是 JavaScript 中提供了 call/apply/bind 三个函数来在函数调用时设置 this 的值。")]),t._v(" "),n("p",[t._v("这三个函数的原型如下：")]),t._v(" "),n("ul",[n("li",[t._v("fun.apply(obj1 [, argsArray])\n"),n("ul",[n("li",[t._v("Sets obj1 as the value of this inside fun() and calls fun() passing elements of argsArray as its arguments.")])])]),t._v(" "),n("li",[t._v("fun.call(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])\n"),n("ul",[n("li",[t._v("Sets obj1 as the value of this inside fun() and calls fun() passing arg1, arg2, arg3, ... as its arguments.")])])]),t._v(" "),n("li",[t._v("fun.bind(obj1 [, arg1 [, arg2 [,arg3 [, ...]]]])\n"),n("ul",[n("li",[t._v("Returns the reference to the function fun with this inside fun() bound to obj1 and parameters of fun bound to the parameters specified arg1, arg2, arg3, ....")])])])]),t._v(" "),n("p",[t._v("下面看一个简单的例子：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function add(numA, numB){\n    console.log( this.original + numA + numB);\n}\n\nadd(1, 2);\n\nvar obj = {original: 10};\nadd.apply(obj, [1, 2]);\nadd.call(obj, 1, 2);\n\nvar f1 = add.bind(obj);\nf1(2, 3);\n\nvar f2 = add.bind(obj, 2);\nf2(3);\n// NaN\n// 13\n// 13\n// 15\n// 15\n")])])]),n("p",[t._v('当直接调用 add 函数的时候，this 将代表 window，当执行"this.original"的时候，由于 window 对象并没有"original"属性，所以会得到"undefined"。')]),t._v(" "),n("p",[t._v("通过 call/apply/bind，达到的效果就是把 add 函数绑定到了 obj 对象上，当调用 add 的时候，this 就代表了 obj 这个对象。")]),t._v(" "),n("h2",{attrs:{id:"dom-event-handler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dom-event-handler"}},[t._v("#")]),t._v(" DOM event handler")]),t._v(" "),n("p",[t._v("当一个函数被当作 event handler 的时候，this 会被设置为触发事件的页面元素（element）。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var body = document.getElementsByTagName("body")[0];\nbody.addEventListener("click", function(){\n    console.log(this);\n});\n// <body>…</body>\n')])])]),n("h3",{attrs:{id:"in-line-event-handler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#in-line-event-handler"}},[t._v("#")]),t._v(" In-line event handler")]),t._v(" "),n("p",[t._v("当代码通过 in-line handler 执行的时候，this 同样指向拥有该 handler 的页面元素。")]),t._v(" "),n("p",[t._v("看下面的代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('document.write(\'<button onclick="console.log(this)">Show this</button>\');\n// <button onclick="console.log(this)">Show this</button>\ndocument.write(\'<button onclick="(function(){console.log(this);})()">Show this</button>\');\n// window\n')])])]),n("p",[t._v('在第一行代码中，正如上面 in-line handler 所描述的，this 将指向"button"这个 element。但是，对于第二行代码中的匿名函数，是一个上下文无关（context-less）的函数，所以 this 会被默认的设置为 window。')]),t._v(" "),n("p",[t._v("前面我们已经介绍过了 bind 函数，所以，通过下面的修改就能改变上面例子中第二行代码的行为：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('document.write(\'<button onclick="((function(){console.log(this);}).bind(this))()">Show this</button>\');\n// <button onclick="((function(){console.log(this);}).bind(this))()">Show this</button>\n')])])]),n("h2",{attrs:{id:"保存-this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#保存-this"}},[t._v("#")]),t._v(" 保存 this")]),t._v(" "),n("p",[t._v("在 JavaScript 代码中，同一个上下文中可能会出现多个 this，为了使用外层的 this，就需要对 this 进行暂存了。")]),t._v(" "),n("p",[t._v('看下面的例子，根据前面的介绍，在 body 元素的 click handler 中，this 肯定是指向 body 这个元素，所以为了使用"greeting"这个方法，就是要对指向 bar 对象的 this 进行暂存，这里用了一个 self 变量。')]),t._v(" "),n("p",[t._v('有了 self，我们就可以在 click handler 中使用 bar 对象的"greeting"方法了。')]),t._v(" "),n("p",[t._v("当阅读一些 JavaScript 库代码的时候，如果遇到类似 self，me，that 的时候，他们可能就是对 this 的暂存。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var bar = {\n    name: "bar",\n    body: document.getElementsByTagName("body")[0],\n\n    greeting: function(){\n        console.log("Hi there, I\'m " + this + ":" + this.name);\n    },\n\n    anotherMethod: function () {\n        var self = this;\n        this.body.addEventListener("click", function(){\n            self.greeting();\n        });\n    }\n};\n\nbar.anotherMethod();\n// Hi there, I\'m [object Object]:bar\n')])])]),n("p",[t._v("同样，对于上面的例子，也可以使用 bind 来设置 this 达到相同的效果。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('var bar = {\n    name: "bar",\n    body: document.getElementsByTagName("body")[0],\n\n    greeting: function(){\n        console.log("Hi there, I\'m " + this + ":" + this.name);\n    },\n\n    anotherMethod: function () {\n        this.body.addEventListener("click", (function(){\n            this.greeting();\n        }).bind(this));\n    }\n};\n\nbar.anotherMethod();\n// Hi there, I\'m [object Object]:bar\n')])])]),n("h2",{attrs:{id:"总结-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结-3"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),n("p",[t._v("本文介绍了执行上下文中的 this 属性，this 的值直接影响着代码的运行结果。")]),t._v(" "),n("p",[t._v("在函数调用中，this 是由激活上下文代码的调用者（caller）来提供的，即调用函数的父上下文(parent context )，也就是说 this 取决于调用函数的方式，指向调用时所在函数所绑定的对象。")]),t._v(" "),n("p",[t._v("通过上面的介绍，相信对 this 有了一定的认识。")]),t._v(" "),n("h2",{attrs:{id:"自己的话总体总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自己的话总体总结"}},[t._v("#")]),t._v(" 自己的话总体总结")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("执行上下文 Execution context 自己的理解就是作用域对象 ：全局作用域 和 局部作用域")]),t._v(" "),n("ul",[n("li",[t._v("包含的重要属性：\n"),n("ul",[n("li",[t._v("变量对象（Variable object，VO）")]),t._v(" "),n("li",[t._v("作用域链（Scope chain）")]),t._v(" "),n("li",[t._v("this")])])]),t._v(" "),n("li",[t._v("创建阶段（当函数被调用，但是开始执行函数内部代码之前）\n"),n("ul",[n("li",[t._v("创建 Scope chain")]),t._v(" "),n("li",[t._v("创建 VO/AO（variables, functions and arguments）\n"),n("ul",[n("li",[t._v("扫描函数内部代码，查找函数声明（Function declaration）")]),t._v(" "),n("li",[t._v("扫描函数内部代码，查找变量声明（Variable declaration）包含 函数的形参")])])]),t._v(" "),n("li",[t._v("设置 this 的值")])])]),t._v(" "),n("li",[t._v("激活/代码执行阶段\n"),n("ul",[n("li",[t._v("设置变量的值、函数的引用，然后解释/执行代码")])])])])]),t._v(" "),n("li",[n("p",[t._v("作用域链 scope chain 就是当前作用域的 VO/AO 没有的变量，就向上查找 VO/AO 一直到全局作用域 Global scope 的 VO")])]),t._v(" "),n("li",[n("p",[t._v("闭包 是作用域链的应用 ：当有下级作用域使用当前作用域内的变量 ，当前作用域执行结束后变量不会被销毁")])]),t._v(" "),n("li",[n("p",[t._v("this 是 当前执行上下文被哪个执行上下文调用 谁调用就指向谁")]),t._v(" "),n("ul",[n("li",[t._v("函数直接调用 fn() 指向 全局对象 global 浏览器中是 window")]),t._v(" "),n("li",[t._v("对象调用 obj.fn() 哪个对象调用指向就指向谁")]),t._v(" "),n("li",[t._v("dom 事件 onclick = fn 指向对应的 dom")]),t._v(" "),n("li",[t._v("构造函数 new Fn() 指向实例对象")]),t._v(" "),n("li",[t._v("call,bind,apply, fn.call(obj) 第一个参数是谁就指向谁")])])])]),t._v(" "),n("h1",{attrs:{id:"javascript-中的函数表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中的函数表达式"}},[t._v("#")]),t._v(" JavaScript 中的函数表达式")])])}),[],!1,null,null,null);n.default=o.exports}}]);